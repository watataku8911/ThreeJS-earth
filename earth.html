<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
  <script src="https://unpkg.com/three@0.137.4/build/three.min.js"></script>
  <script>
    // ページの読み込みを待つ
    window.onload = () => {
        init()
    }

    // サイズを指定
    const width = window.innerWidth;
    const height = window.innerHeight;
    let rot = 0;
    let mouseX = 0;

    const init = () => {
        const canvasElement = document.querySelector('#myCanvas');
        // レンダラーを作成
        const renderer = new THREE.WebGLRenderer({
            canvas: canvasElement
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);

        // シーンを作成
        const scene = new THREE.Scene();

        // カメラを作成
        const camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
       //const camera = new THREE.OrthographicCamera(-480, +480, 270, -270, 1, 2000);
        camera.position.set(0, 0, +1000);

        // 球体を作成
        const geometry = new THREE.SphereGeometry(350, 30, 30);
        const loader = new THREE.TextureLoader();

        // // マテリアルにテクスチャーを設定
        const material = new THREE.MeshStandardMaterial({
            map: new THREE.TextureLoader().load('earthmap1k.jpeg')
        });

        // メッシュを作成
        const earthMesh = new THREE.Mesh(geometry, material);

        // 3D空間にメッシュを追加
        scene.add(earthMesh);

       

        /** 星屑を作成します */
        const createStarField = () => {
        // 頂点情報を格納する配列
            const vertices = [];
            // 1000 個の頂点を作成
            for (let i = 0; i < 1000; i++) {
                const x = 3000 * (Math.random() - 0.5);
                const y = 3000 * (Math.random() - 0.5);
                const z = 3000 * (Math.random() - 0.5);

                vertices.push(x, y, z);
            }

            // 形状データを作成
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            // マテリアルを作成
            const material = new THREE.PointsMaterial({
                size: 10,
                color: 0xffffff,
            });

            // 物体を作成
            const mesh = new THREE.Points(geometry, material);
            scene.add(mesh);
        }

        createStarField();

        // 平行光源
        const directionalLight = new THREE.DirectionalLight(0xFFFFFF);
        directionalLight.position.set(1, 1, 1);

        // シーンに追加
        scene.add(directionalLight);

        // マウス座標はマウスが動いた時のみ取得できる
        document.addEventListener("mousemove", (event) => {
          mouseX = event.pageX;
        });

        // 毎フレーム時に実行されるループイベントです
        const tick = () => {
          // マウスの位置に応じて角度を設定
          // マウスのX座標がステージの幅の何%の位置にあるか調べてそれを360度で乗算する
          const targetRot = (mouseX / window.innerWidth) * 360;
          // イージングの公式を用いて滑らかにする
          // 値 += (目標値 - 現在の値) * 減速値
          rot += (targetRot - rot) * 0.02;
          // ラジアンに変換する
          const radian = (rot * Math.PI) / 180;
          // 角度に応じてカメラの位置を設定
          camera.position.x = 1000 * Math.sin(radian);
          camera.position.z = 1000 * Math.cos(radian);
          // 原点方向を見つめる
          camera.lookAt(new THREE.Vector3(0, 0, 0));

          // 地球は常に回転させておく
          earthMesh.rotation.y += 0.01;
          // レンダリング
          renderer.render(scene, camera);

          requestAnimationFrame(tick);
        }

        tick();
        
    }

  </script>
</head>
<body>
  <canvas id="myCanvas"></canvas>

</body>
</html>